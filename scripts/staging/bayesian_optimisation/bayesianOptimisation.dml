# INPUT PARAMETERS:
# -----------------------------------------------------------------------------------------------------
# NAME           TYPE           DEFAULT  MEANING
# -----------------------------------------------------------------------------------------------------
# X              Matrix[Double]  ---     Model.
# y              Matrix[Double]  ---     Targets.
# fAqu           String          ---     Name of the aquisition function to optimize.
# kernel         String          ---     Kernelfunction to use.
# paramNames     Matrix[String]  ---     Name of the hyper parameters to optimize.
# paramValues    Matrix[Double]  ---     Values of the hyper parameters to optimize.
# iterations     Integer         ---     Number of training interations.  
#
source("./scripts/staging/scalable_linalg/linalg_decomp.dml") as decomp


m_bayesianOptimisation = function(Matrix[Double] X, Matrix[Double] y, String fTrain, List[String] params, List[Unknown] paramValues, String fAqu, String kernel, Integer iterations, Boolean verbose = TRUE)
  return (Matrix[Double] B, Frame[Unknown] opt)
{
    numParams = length(params);
    paramLens = matrix(0, numParams, 1);
    for( j in 1:numParams ) {
      vect = as.matrix(paramValues[j,1]);
      paramLens[j,1] = nrow(vect);
    }
    paramVals = matrix(0, numParams, max(paramLens));
    for( j in 1:numParams ) {
      vect = as.matrix(paramValues[j,1]);
      paramVals[j,1:nrow(vect)] = t(vect);
    }

    # loop
    for (i in 1:iterations) {
        #print("iteration" + i);

        kArgs = list(X, X);
        kernel_result = eval(kernel, kArgs);

        #aArgs = list(X, y);
        #aquisition_result = eval(fAqu, aArgs);

        #tArgs = list(
        #eval(fTain, tArgs);

        print(toString(kernel_result));
    }
    B = X;
    opt = as.frame(y);
    print("Works");
}
